{"file_contents":{"README.md":{"content":"# AI-Powered Digital Examination System\n\nA comprehensive digital examination platform built with Flask that leverages AI for question generation, automated evaluation, and intelligent exam management.\n\n## ðŸŒŸ Features\n\n### Core Functionality\n- **Role-based Authentication**: Separate interfaces for administrators and students using Replit OAuth\n- **AI Question Generation**: Automatically generate unique questions using OpenAI's GPT-4o model\n- **Exam Management**: Create, publish, and manage exams with flexible settings\n- **Timed Examinations**: Built-in countdown timer with automatic submission\n- **Anti-Cheat Measures**: Tab switching detection, question randomization, and session monitoring\n- **Automated Evaluation**: Instant grading for multiple-choice questions\n- **Comprehensive Analytics**: Detailed performance statistics and reporting\n\n### Admin Features\n- Create exams with AI-generated questions\n- Subject and difficulty level management\n- Question approval and review workflow\n- Real-time exam monitoring\n- Performance analytics and reporting\n- Student result management\n\n### Student Features\n- Responsive exam interface\n- Real-time timer with visual warnings\n- Progress tracking and navigation\n- Auto-save functionality\n- Detailed result viewing\n- Mobile-friendly design\n\n### AI Integration\n- **Question Generation**: Create contextually relevant questions based on subject and difficulty\n- **Question Variations**: Generate multiple versions to prevent cheating\n- **Content Adaptation**: Adjust difficulty and complexity automatically\n- **Future Enhancement**: Subjective answer evaluation (framework ready)\n\n## ðŸ—ï¸ System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Frontend Layer\"\n        A[Web Interface - HTML/CSS/JS]\n        B[Admin Dashboard]\n        C[Student Exam Interface]\n        D[Mobile Responsive UI]\n    end\n    \n    subgraph \"Authentication\"\n        E[Replit OAuth]\n        F[Role-Based Access Control]\n    end\n    \n    subgraph \"Backend Services\"\n        G[Flask Application Server]\n        H[Exam Management Service]\n        I[AI Question Generator]\n        J[Evaluation Engine]\n        K[Timer & Anti-Cheat Service]\n    end\n    \n    subgraph \"AI Integration\"\n        L[OpenAI API]\n        M[Question Generation]\n        N[Answer Evaluation]\n        O[Question Variations]\n    end\n    \n    subgraph \"Data Layer\"\n        P[SQLite Database]\n        Q[User Management]\n        R[Exam Storage]\n        S[Results Analytics]\n    end\n    \n    subgraph \"Security & Integrity\"\n        T[Session Management]\n        U[Question Randomization]\n        V[Tab Switch Detection]\n        W[Time Validation]\n    end\n","size_bytes":2647},"ai_service.py":{"content":"import json\nimport os\nfrom openai import OpenAI\n\n# Using OpenRouter API for AI model access\n# the newest OpenAI model is \"gpt-4o\" which was released May 13, 2024.\n# do not change this unless explicitly requested by the user\nOPENROUTER_API_KEY = os.environ.get(\"OPENROUTER_API_KEY\")\nopenai = OpenAI(\n    api_key=OPENROUTER_API_KEY,\n    base_url=\"https://openrouter.ai/api/v1\"\n)\n\ndef generate_questions(subject, topic, difficulty, num_questions=10, question_type=\"multiple_choice\"):\n    \"\"\"\n    Generate exam questions using OpenAI API\n    \"\"\"\n    try:\n        # Create a comprehensive prompt for question generation\n        prompt = f\"\"\"\n        Generate {num_questions} {question_type} questions for an exam on the subject \"{subject}\" \n        with the topic \"{topic}\" at {difficulty} difficulty level.\n        \n        For each question, provide:\n        1. Clear, well-formed question text\n        2. Four answer options (A, B, C, D) for multiple choice questions\n        3. The correct answer (A, B, C, or D)\n        4. Ensure questions test understanding, not just memorization\n        5. Make questions appropriate for {difficulty} level\n        \n        Return the response as a JSON object with this exact structure:\n        {{\n            \"questions\": [\n                {{\n                    \"question_text\": \"Question text here\",\n                    \"option_a\": \"Option A text\",\n                    \"option_b\": \"Option B text\", \n                    \"option_c\": \"Option C text\",\n                    \"option_d\": \"Option D text\",\n                    \"correct_answer\": \"A\",\n                    \"points\": 1\n                }}\n            ]\n        }}\n        \n        Make sure all questions are unique and cover different aspects of the topic.\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"openai/gpt-4o\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert exam question generator. Create high-quality, educational questions that test student understanding effectively.\"\n                },\n                {\n                    \"role\": \"user\", \n                    \"content\": prompt\n                }\n            ],\n            response_format={\"type\": \"json_object\"},\n            temperature=0.7\n        )\n        \n        content = response.choices[0].message.content\n        if not content:\n            raise Exception(\"Empty response from OpenAI API\")\n        result = json.loads(content)\n        return result[\"questions\"]\n        \n    except Exception as e:\n        raise Exception(f\"Failed to generate questions: {str(e)}\")\n\ndef evaluate_subjective_answer(question, student_answer, correct_answer=None):\n    \"\"\"\n    Evaluate subjective answers using AI\n    \"\"\"\n    try:\n        prompt = f\"\"\"\n        Evaluate the following student answer for the given question:\n        \n        Question: {question}\n        Student Answer: {student_answer}\n        {f\"Expected/Reference Answer: {correct_answer}\" if correct_answer else \"\"}\n        \n        Please evaluate the answer on a scale of 0-100 and provide:\n        1. A score (0-100)\n        2. Brief feedback explaining the score\n        3. Key points that were covered or missed\n        \n        Return as JSON:\n        {{\n            \"score\": 85,\n            \"feedback\": \"Good understanding shown but missing key concept X\",\n            \"points_covered\": [\"Point 1\", \"Point 2\"],\n            \"points_missed\": [\"Point 3\"]\n        }}\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"openai/gpt-4o\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert educator evaluating student answers. Be fair but thorough in your assessment.\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": prompt\n                }\n            ],\n            response_format={\"type\": \"json_object\"}\n        )\n        \n        content = response.choices[0].message.content\n        if not content:\n            raise Exception(\"Empty response from OpenAI API\")\n        return json.loads(content)\n        \n    except Exception as e:\n        raise Exception(f\"Failed to evaluate answer: {str(e)}\")\n\ndef generate_question_variations(base_question, num_variations=3):\n    \"\"\"\n    Generate variations of a question to prevent cheating\n    \"\"\"\n    try:\n        prompt = f\"\"\"\n        Create {num_variations} variations of this question that test the same concept but with different wording, numbers, or examples:\n        \n        Original Question: {base_question['question_text']}\n        Original Options:\n        A) {base_question['option_a']}\n        B) {base_question['option_b']}\n        C) {base_question['option_c']}\n        D) {base_question['option_d']}\n        Correct Answer: {base_question['correct_answer']}\n        \n        For each variation, maintain the same difficulty level and learning objective.\n        \n        Return as JSON:\n        {{\n            \"variations\": [\n                {{\n                    \"question_text\": \"Variation question text\",\n                    \"option_a\": \"Option A\",\n                    \"option_b\": \"Option B\",\n                    \"option_c\": \"Option C\", \n                    \"option_d\": \"Option D\",\n                    \"correct_answer\": \"B\"\n                }}\n            ]\n        }}\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert at creating question variations while maintaining educational value and difficulty.\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": prompt\n                }\n            ],\n            response_format={\"type\": \"json_object\"}\n        )\n        \n        content = response.choices[0].message.content\n        if not content:\n            raise Exception(\"Empty response from OpenAI API\")\n        return json.loads(content)[\"variations\"]\n        \n    except Exception as e:\n        raise Exception(f\"Failed to generate variations: {str(e)}\")\n","size_bytes":6274},"app.py":{"content":"import os\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# Create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # needed for url_for to generate with https\n\n# Configure the database, relative to the app instance folder\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# Initialize the app with the extension\ndb.init_app(app)\n\nwith app.app_context():\n    # Make sure to import the models here or their tables won't be created\n    import models  # noqa: F401\n    db.create_all()\n    logging.info(\"Database tables created\")\n","size_bytes":999},"exam_service.py":{"content":"from datetime import datetime, timedelta\nfrom app import db\nfrom models import Exam, Question, ExamSession, Answer, Subject, User\nimport random\n\ndef create_exam_session(exam_id, student_id):\n    \"\"\"\n    Create a new exam session for a student\n    \"\"\"\n    # Check if student already has an active session for this exam\n    existing_session = ExamSession.query.filter_by(\n        exam_id=exam_id,\n        student_id=student_id,\n        is_submitted=False\n    ).first()\n    \n    if existing_session:\n        return existing_session\n    \n    # Create new session\n    exam_session = ExamSession()\n    exam_session.exam_id = exam_id\n    exam_session.student_id = student_id\n    exam_session.start_time = datetime.now()\n    \n    db.session.add(exam_session)\n    db.session.commit()\n    \n    return exam_session\n\ndef get_randomized_questions(exam_id, student_id):\n    \"\"\"\n    Get questions for an exam, randomized per student to prevent cheating\n    \"\"\"\n    questions = Question.query.filter_by(exam_id=exam_id).order_by(Question.order_index).all()\n    \n    # Create a deterministic but unique shuffle based on student_id\n    random.seed(hash(str(student_id) + str(exam_id)) % (2**32))\n    randomized_questions = questions.copy()\n    random.shuffle(randomized_questions)\n    \n    # Reset random seed\n    random.seed()\n    \n    return randomized_questions\n\ndef submit_answer(exam_session_id, question_id, student_answer):\n    \"\"\"\n    Submit an answer for a question in an exam session\n    \"\"\"\n    # Check if answer already exists\n    existing_answer = Answer.query.filter_by(\n        exam_session_id=exam_session_id,\n        question_id=question_id\n    ).first()\n    \n    if existing_answer:\n        existing_answer.student_answer = student_answer\n    else:\n        answer = Answer()\n        answer.exam_session_id = exam_session_id\n        answer.question_id = question_id\n        answer.student_answer = student_answer\n        db.session.add(answer)\n    \n    db.session.commit()\n\ndef evaluate_exam_session(exam_session_id):\n    \"\"\"\n    Evaluate all answers in an exam session\n    \"\"\"\n    exam_session = ExamSession.query.get(exam_session_id)\n    if not exam_session:\n        return False\n    \n    answers = Answer.query.filter_by(exam_session_id=exam_session_id).all()\n    total_points = 0\n    earned_points = 0\n    \n    for answer in answers:\n        question = Question.query.get(answer.question_id)\n        if not question:\n            continue  # Skip if question not found\n            \n        total_points += question.points\n        \n        # Auto-evaluate objective questions\n        if question.question_type == 'multiple_choice':\n            if answer.student_answer and answer.student_answer.upper() == question.correct_answer.upper():\n                answer.is_correct = True\n                answer.points_earned = question.points\n                earned_points += question.points\n            else:\n                answer.is_correct = False\n                answer.points_earned = 0\n        \n        # For subjective questions, manual evaluation needed\n        # For now, mark as requiring manual review\n        elif question.question_type in ['short_answer', 'essay']:\n            answer.is_correct = None  # Pending manual review\n            answer.points_earned = 0  # Will be updated after manual review\n    \n    # Update exam session with results\n    exam_session.total_points = total_points\n    exam_session.score = (earned_points / total_points * 100) if total_points > 0 else 0\n    exam_session.is_evaluated = True\n    exam_session.end_time = datetime.now()\n    \n    db.session.commit()\n    \n    return True\n\ndef finish_exam_session(exam_session_id):\n    \"\"\"\n    Mark an exam session as completed and evaluate it\n    \"\"\"\n    exam_session = ExamSession.query.get(exam_session_id)\n    if not exam_session:\n        return False\n    \n    exam_session.is_submitted = True\n    exam_session.end_time = datetime.now()\n    \n    db.session.commit()\n    \n    # Auto-evaluate the session\n    evaluate_exam_session(exam_session_id)\n    \n    return True\n\ndef get_exam_time_remaining(exam_session):\n    \"\"\"\n    Calculate remaining time for an exam session\n    \"\"\"\n    if exam_session.is_submitted:\n        return 0\n    \n    exam = exam_session.exam\n    elapsed_time = datetime.now() - exam_session.start_time\n    total_duration = timedelta(minutes=exam.duration_minutes)\n    \n    remaining = total_duration - elapsed_time\n    \n    if remaining.total_seconds() <= 0:\n        # Time's up, auto-submit\n        finish_exam_session(exam_session.id)\n        return 0\n    \n    return int(remaining.total_seconds())\n\ndef get_student_exam_history(student_id):\n    \"\"\"\n    Get all completed exams for a student\n    \"\"\"\n    sessions = ExamSession.query.filter_by(\n        student_id=student_id,\n        is_submitted=True\n    ).order_by(ExamSession.created_at.desc()).all()\n    \n    return sessions\n\ndef get_exam_statistics(exam_id):\n    \"\"\"\n    Get statistics for an exam\n    \"\"\"\n    sessions = ExamSession.query.filter_by(\n        exam_id=exam_id,\n        is_submitted=True,\n        is_evaluated=True\n    ).all()\n    \n    if not sessions:\n        return {\n            'total_attempts': 0,\n            'average_score': 0,\n            'highest_score': 0,\n            'lowest_score': 0,\n            'pass_rate': 0\n        }\n    \n    scores = [session.score for session in sessions]\n    pass_count = len([score for score in scores if score >= 60])  # Assuming 60% is passing\n    \n    return {\n        'total_attempts': len(sessions),\n        'average_score': sum(scores) / len(scores),\n        'highest_score': max(scores),\n        'lowest_score': min(scores),\n        'pass_rate': (pass_count / len(sessions)) * 100\n    }\n","size_bytes":5705},"main.py":{"content":"from app import app\nimport routes  # noqa: F401\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":127},"models.py":{"content":"from datetime import datetime\nfrom app import db\nfrom flask_dance.consumer.storage.sqla import OAuthConsumerMixin\nfrom flask_login import UserMixin\nfrom sqlalchemy import UniqueConstraint\nfrom enum import Enum\n\n# (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.String, primary_key=True)\n    email = db.Column(db.String, unique=True, nullable=True)\n    first_name = db.Column(db.String, nullable=True)\n    last_name = db.Column(db.String, nullable=True)\n    profile_image_url = db.Column(db.String, nullable=True)\n    role = db.Column(db.String, default='student')  # 'admin' or 'student'\n    \n    created_at = db.Column(db.DateTime, default=datetime.now)\n    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n    \n    # Relationships\n    created_exams = db.relationship('Exam', back_populates='creator', lazy=True)\n    exam_sessions = db.relationship('ExamSession', back_populates='student', lazy=True)\n\n# (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nclass OAuth(OAuthConsumerMixin, db.Model):\n    user_id = db.Column(db.String, db.ForeignKey(User.id))\n    browser_session_key = db.Column(db.String, nullable=False)\n    user = db.relationship(User)\n\n    __table_args__ = (UniqueConstraint(\n        'user_id',\n        'browser_session_key',\n        'provider',\n        name='uq_user_browser_session_key_provider',\n    ),)\n\nclass Subject(db.Model):\n    __tablename__ = 'subjects'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    # Relationships\n    exams = db.relationship('Exam', back_populates='subject', lazy=True)\n\nclass Exam(db.Model):\n    __tablename__ = 'exams'\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    subject_id = db.Column(db.Integer, db.ForeignKey('subjects.id'), nullable=False)\n    creator_id = db.Column(db.String, db.ForeignKey('users.id'), nullable=False)\n    difficulty_level = db.Column(db.String(20), default='medium')  # easy, medium, hard\n    duration_minutes = db.Column(db.Integer, default=60)\n    total_questions = db.Column(db.Integer, default=10)\n    is_published = db.Column(db.Boolean, default=False)\n    is_active = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n    \n    # Relationships\n    subject = db.relationship('Subject', back_populates='exams')\n    creator = db.relationship('User', back_populates='created_exams')\n    questions = db.relationship('Question', back_populates='exam', lazy=True, cascade='all, delete-orphan')\n    exam_sessions = db.relationship('ExamSession', back_populates='exam', lazy=True)\n\nclass Question(db.Model):\n    __tablename__ = 'questions'\n    id = db.Column(db.Integer, primary_key=True)\n    exam_id = db.Column(db.Integer, db.ForeignKey('exams.id'), nullable=False)\n    question_text = db.Column(db.Text, nullable=False)\n    question_type = db.Column(db.String(20), default='multiple_choice')  # multiple_choice, true_false, short_answer\n    option_a = db.Column(db.Text)\n    option_b = db.Column(db.Text)\n    option_c = db.Column(db.Text)\n    option_d = db.Column(db.Text)\n    correct_answer = db.Column(db.String(10))  # A, B, C, D for MCQ, or actual answer for other types\n    points = db.Column(db.Integer, default=1)\n    order_index = db.Column(db.Integer, default=0)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    # Relationships\n    exam = db.relationship('Exam', back_populates='questions')\n    answers = db.relationship('Answer', back_populates='question', lazy=True)\n\nclass ExamSession(db.Model):\n    __tablename__ = 'exam_sessions'\n    id = db.Column(db.Integer, primary_key=True)\n    exam_id = db.Column(db.Integer, db.ForeignKey('exams.id'), nullable=False)\n    student_id = db.Column(db.String, db.ForeignKey('users.id'), nullable=False)\n    start_time = db.Column(db.DateTime, default=datetime.now)\n    end_time = db.Column(db.DateTime)\n    is_submitted = db.Column(db.Boolean, default=False)\n    score = db.Column(db.Float, default=0.0)\n    total_points = db.Column(db.Integer, default=0)\n    is_evaluated = db.Column(db.Boolean, default=False)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    # Relationships\n    exam = db.relationship('Exam', back_populates='exam_sessions')\n    student = db.relationship('User', back_populates='exam_sessions')\n    answers = db.relationship('Answer', back_populates='exam_session', lazy=True, cascade='all, delete-orphan')\n\nclass Answer(db.Model):\n    __tablename__ = 'answers'\n    id = db.Column(db.Integer, primary_key=True)\n    exam_session_id = db.Column(db.Integer, db.ForeignKey('exam_sessions.id'), nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('questions.id'), nullable=False)\n    student_answer = db.Column(db.Text)\n    is_correct = db.Column(db.Boolean)\n    points_earned = db.Column(db.Float, default=0.0)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    # Relationships\n    exam_session = db.relationship('ExamSession', back_populates='answers')\n    question = db.relationship('Question', back_populates='answers')\n","size_bytes":5492},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask-dance>=7.1.0\",\n    \"flask>=3.1.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"openai>=1.99.9\",\n    \"psycopg2-binary>=2.9.10\",\n    \"pyjwt>=2.10.1\",\n    \"flask-login>=0.6.3\",\n    \"oauthlib>=3.3.1\",\n]\n","size_bytes":398},"replit.md":{"content":"# Overview\n\nThe AI-Powered Digital Examination System is a comprehensive web-based platform built with Flask that leverages artificial intelligence for creating, managing, and evaluating digital exams. The system features role-based access control for administrators and students, AI-powered question generation using OpenAI's GPT-4o model, automated evaluation, real-time exam monitoring, and comprehensive analytics. The platform includes anti-cheat measures such as tab switching detection, question randomization per student, and session monitoring to ensure exam integrity.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Backend Architecture\nThe application is built on Flask with SQLAlchemy for database operations using a declarative base model approach. The system follows a modular design with separate service layers for different functionalities:\n\n- **Core Application**: Flask app with session management and database configuration\n- **Authentication Service**: Replit OAuth integration with custom storage for user sessions and role-based access control\n- **AI Service**: OpenAI GPT-4o integration for intelligent question generation with customizable parameters for subject, topic, difficulty, and question type\n- **Exam Service**: Business logic for exam session management, question randomization, answer submission, and automated evaluation\n\n## Database Architecture\nThe system uses SQLAlchemy ORM with the following core entities:\n- **User Management**: User and OAuth tables (mandatory for Replit Auth) with role-based access (admin/student)\n- **Content Management**: Subject, Exam, Question, ExamSession, and Answer tables with proper relationships\n- **Session Tracking**: Exam sessions with timing, submission status, and scoring information\n\n## Frontend Architecture  \nThe frontend uses Bootstrap with Replit's dark theme for consistent styling:\n- **Responsive Design**: Mobile-friendly interface with Bootstrap grid system\n- **Real-time Features**: JavaScript-based exam timer, progress tracking, and auto-save functionality\n- **Template Structure**: Jinja2 templates with base template inheritance for consistent layout\n- **Interactive Components**: Dynamic question navigation, timer warnings, and form validation\n\n## Anti-Cheat and Security Measures\n- **Session Security**: Browser session keys tied to OAuth tokens\n- **Question Randomization**: Deterministic but unique question shuffling per student using seeded random generation\n- **Client-side Monitoring**: Tab switching detection and session monitoring via JavaScript\n- **Time Management**: Server-side time validation with automatic submission on timeout\n\n## AI Integration Strategy\n- **Question Generation**: OpenRouter API with GPT-4o model using structured prompts for creating multiple-choice questions\n- **Content Customization**: Dynamic difficulty adjustment and topic-specific question creation\n- **Quality Control**: Structured JSON response format with validation for consistency\n- **Extensibility**: Framework ready for subjective answer evaluation and question variations\n- **Provider Flexibility**: OpenRouter allows easy switching between different AI model providers\n\n# External Dependencies\n\n## Authentication Services\n- **Replit OAuth**: Primary authentication provider with custom storage implementation\n- **Flask-Login**: Session management and user authentication state handling\n\n## AI and Machine Learning\n- **OpenRouter API**: Unified access to multiple AI models including OpenAI's GPT-4o for intelligent question generation and content creation\n- **Custom AI Service**: Wrapper service for OpenRouter integration with structured prompting and automatic model routing\n\n## Database and Storage\n- **SQLAlchemy**: ORM for database operations with declarative base model\n- **Database**: Configurable via DATABASE_URL environment variable (supports PostgreSQL and other databases)\n\n## Frontend Libraries\n- **Bootstrap**: UI framework with Replit's dark theme for consistent styling\n- **Feather Icons**: Icon library for modern, consistent iconography\n- **Custom JavaScript**: Exam timer, navigation, and anti-cheat functionality\n\n## Development and Deployment\n- **Flask Framework**: Core web framework with WSGI application structure\n- **Werkzeug ProxyFix**: For proper URL generation in deployed environments\n- **Environment Configuration**: Uses environment variables for sensitive data and configuration\n\n## Third-party Integrations\n- **Mermaid**: For system architecture diagram rendering in documentation\n- **jQuery/Vanilla JS**: For client-side interactivity and AJAX operations","size_bytes":4645},"replit_auth.py":{"content":"import jwt\nimport os\nimport uuid\nfrom functools import wraps\nfrom urllib.parse import urlencode\n\nfrom flask import g, session, redirect, request, render_template, url_for\nfrom flask_dance.consumer import (\n    OAuth2ConsumerBlueprint,\n    oauth_authorized,\n    oauth_error,\n)\nfrom flask_dance.consumer.storage import BaseStorage\nfrom flask_login import LoginManager, login_user, logout_user, current_user\nfrom oauthlib.oauth2.rfc6749.errors import InvalidGrantError\nfrom sqlalchemy.exc import NoResultFound\nfrom werkzeug.local import LocalProxy\n\nfrom app import app, db\nfrom models import OAuth, User\n\n# Global issuer URL for use throughout the module\nISSUER_URL = os.environ.get('ISSUER_URL', \"https://replit.com/oidc\")\n\nlogin_manager = LoginManager(app)\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(user_id)\n\nclass UserSessionStorage(BaseStorage):\n    def get(self, blueprint):\n        try:\n            token = db.session.query(OAuth).filter_by(\n                user_id=current_user.get_id(),\n                browser_session_key=g.browser_session_key,\n                provider=blueprint.name,\n            ).one().token\n        except NoResultFound:\n            token = None\n        return token\n\n    def set(self, blueprint, token):\n        db.session.query(OAuth).filter_by(\n            user_id=current_user.get_id(),\n            browser_session_key=g.browser_session_key,\n            provider=blueprint.name,\n        ).delete()\n        new_model = OAuth()\n        new_model.user_id = current_user.get_id()\n        new_model.browser_session_key = g.browser_session_key\n        new_model.provider = blueprint.name\n        new_model.token = token\n        db.session.add(new_model)\n        db.session.commit()\n\n    def delete(self, blueprint):\n        db.session.query(OAuth).filter_by(\n            user_id=current_user.get_id(),\n            browser_session_key=g.browser_session_key,\n            provider=blueprint.name).delete()\n        db.session.commit()\n\ndef make_replit_blueprint():\n    try:\n        repl_id = os.environ['REPL_ID']\n    except KeyError:\n        raise SystemExit(\"the REPL_ID environment variable must be set\")\n\n    replit_bp = OAuth2ConsumerBlueprint(\n        \"replit_auth\",\n        __name__,\n        client_id=repl_id,\n        client_secret=None,\n        base_url=ISSUER_URL,\n        authorization_url_params={\n            \"prompt\": \"login consent\",\n        },\n        token_url=ISSUER_URL + \"/token\",\n        token_url_params={\n            \"auth\": (),\n            \"include_client_id\": True,\n        },\n        auto_refresh_url=ISSUER_URL + \"/token\",\n        auto_refresh_kwargs={\n            \"client_id\": repl_id,\n        },\n        authorization_url=ISSUER_URL + \"/auth\",\n        use_pkce=True,\n        code_challenge_method=\"S256\",\n        scope=[\"openid\", \"profile\", \"email\", \"offline_access\"],\n        storage=UserSessionStorage(),\n    )\n\n    @replit_bp.before_app_request\n    def set_applocal_session():\n        if '_browser_session_key' not in session:\n            session['_browser_session_key'] = uuid.uuid4().hex\n        session.modified = True\n        g.browser_session_key = session['_browser_session_key']\n        g.flask_dance_replit = replit_bp.session\n\n    @replit_bp.route(\"/logout\")\n    def logout():\n        del replit_bp.token\n        logout_user()\n\n        end_session_endpoint = ISSUER_URL + \"/session/end\"\n        encoded_params = urlencode({\n            \"client_id\": repl_id,\n            \"post_logout_redirect_uri\": request.url_root,\n        })\n        logout_url = f\"{end_session_endpoint}?{encoded_params}\"\n\n        return redirect(logout_url)\n\n    @replit_bp.route(\"/error\")\n    def error():\n        return render_template(\"403.html\"), 403\n\n    return replit_bp\n\ndef save_user(user_claims):\n    user = User()\n    user.id = user_claims['sub']\n    user.email = user_claims.get('email')\n    user.first_name = user_claims.get('first_name')\n    user.last_name = user_claims.get('last_name')\n    user.profile_image_url = user_claims.get('profile_image_url')\n    \n    # Smart role assignment for new users\n    existing_user = User.query.get(user.id)\n    if not existing_user:\n        # Auto-assign admin role based on criteria\n        user.role = assign_user_role(user_claims)\n    else:\n        user.role = existing_user.role  # Preserve existing role\n    \n    merged_user = db.session.merge(user)\n    db.session.commit()\n    return merged_user\n\ndef assign_user_role(user_claims):\n    \"\"\"\n    Automatically assign user role based on criteria\n    \"\"\"\n    email = user_claims.get('email', '').lower()\n    \n    # Admin criteria - you can customize these rules\n    admin_domains = ['admin.com', 'teacher.edu', 'instructor.org']\n    admin_keywords = ['admin', 'teacher', 'instructor', 'professor', 'educator']\n    \n    # Check if email domain suggests admin role\n    if any(domain in email for domain in admin_domains):\n        return 'admin'\n    \n    # Check if email contains admin keywords\n    if any(keyword in email for keyword in admin_keywords):\n        return 'admin'\n    \n    # Check if this is the first user (make them admin)\n    user_count = User.query.count()\n    if user_count == 0:\n        return 'admin'\n    \n    # Default to student role\n    return 'student'\n\n@oauth_authorized.connect\ndef logged_in(blueprint, token):\n    user_claims = jwt.decode(token['id_token'], options={\"verify_signature\": False})\n    user = save_user(user_claims)\n    login_user(user)\n    blueprint.token = token\n    next_url = session.pop(\"next_url\", None)\n    if next_url is not None:\n        return redirect(next_url)\n\n@oauth_error.connect\ndef handle_error(blueprint, error, error_description=None, error_uri=None):\n    return redirect(url_for('replit_auth.error'))\n\ndef require_login(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not current_user.is_authenticated:\n            session[\"next_url\"] = get_next_navigation_url(request)\n            return redirect(url_for('replit_auth.login'))\n\n        expires_in = replit.token.get('expires_in', 0)\n        if expires_in < 0:\n            refresh_token_url = ISSUER_URL + \"/token\"\n            try:\n                token = replit.refresh_token(token_url=refresh_token_url,\n                                             client_id=os.environ['REPL_ID'])\n            except InvalidGrantError:\n                session[\"next_url\"] = get_next_navigation_url(request)\n                return redirect(url_for('replit_auth.login'))\n            replit.token_updater(token)\n\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef require_admin(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not current_user.is_authenticated:\n            session[\"next_url\"] = get_next_navigation_url(request)\n            return redirect(url_for('replit_auth.login'))\n        \n        if current_user.role != 'admin':\n            return render_template(\"403.html\"), 403\n            \n        return f(*args, **kwargs)\n    return decorated_function\n\ndef get_next_navigation_url(request):\n    is_navigation_url = request.headers.get('Sec-Fetch-Mode') == 'navigate' and request.headers.get('Sec-Fetch-Dest') == 'document'\n    if is_navigation_url:\n        return request.url\n    return request.referrer or request.url\n\nreplit = LocalProxy(lambda: g.flask_dance_replit)\n","size_bytes":7316},"routes.py":{"content":"from flask import session, render_template, request, redirect, url_for, flash, jsonify\nfrom app import app, db\nfrom replit_auth import require_login, require_admin, make_replit_blueprint\nfrom flask_login import current_user\nfrom models import User, Subject, Exam, Question, ExamSession, Answer\nfrom ai_service import generate_questions, generate_question_variations\nfrom exam_service import (\n    create_exam_session, get_randomized_questions, submit_answer,\n    finish_exam_session, get_exam_time_remaining, get_student_exam_history,\n    get_exam_statistics\n)\nfrom datetime import datetime\nimport logging\n\napp.register_blueprint(make_replit_blueprint(), url_prefix=\"/auth\")\n\n# Make session permanent\n@app.before_request\ndef make_session_permanent():\n    session.permanent = True\n\n@app.route('/')\ndef index():\n    \"\"\"Landing page - redirect based on user role\"\"\"\n    if current_user.is_authenticated:\n        if current_user.role == 'admin':\n            return redirect(url_for('admin_dashboard'))\n        else:\n            return redirect(url_for('student_dashboard'))\n    \n    return render_template('index.html')\n\n@app.route('/switch-to-admin')\n@require_login\ndef switch_to_admin():\n    \"\"\"Switch current user to admin role (for demo purposes)\"\"\"\n    current_user.role = 'admin'\n    db.session.commit()\n    flash('You are now an administrator!', 'success')\n    return redirect(url_for('admin_dashboard'))\n\n@app.route('/switch-to-student')\n@require_login  \ndef switch_to_student():\n    \"\"\"Switch current user to student role\"\"\"\n    current_user.role = 'student'\n    db.session.commit()\n    flash('You are now a student!', 'info')\n    return redirect(url_for('student_dashboard'))\n\n@app.route('/admin/users')\n@require_admin\ndef manage_users():\n    \"\"\"Admin interface to manage users\"\"\"\n    users = User.query.order_by(User.id).all()\n    return render_template('admin/users.html', users=users)\n\n@app.route('/admin/users/<user_id>/toggle-role', methods=['POST'])\n@require_admin\ndef toggle_user_role(user_id):\n    \"\"\"Toggle user role between admin and student\"\"\"\n    user = User.query.get_or_404(user_id)\n    \n    if user.id == current_user.id:\n        flash('You cannot change your own role!', 'error')\n        return redirect(url_for('manage_users'))\n    \n    # Toggle role\n    user.role = 'student' if user.role == 'admin' else 'admin'\n    db.session.commit()\n    \n    flash(f'User {user.first_name or user.email} is now a {user.role}!', 'success')\n    return redirect(url_for('manage_users'))\n\n# Admin Routes\n@app.route('/admin')\n@require_admin\ndef admin_dashboard():\n    \"\"\"Admin dashboard with exam management\"\"\"\n    exams = Exam.query.filter_by(creator_id=current_user.id).order_by(Exam.created_at.desc()).all()\n    subjects = Subject.query.all()\n    \n    # Get statistics for each exam\n    exam_stats = {}\n    for exam in exams:\n        exam_stats[exam.id] = get_exam_statistics(exam.id)\n    \n    # Get user statistics\n    total_users = User.query.count()\n    admin_users = User.query.filter_by(role='admin').count()\n    student_users = User.query.filter_by(role='student').count()\n    \n    return render_template('admin/dashboard.html', \n                         exams=exams, \n                         subjects=subjects, \n                         exam_stats=exam_stats,\n                         total_users=total_users,\n                         admin_users=admin_users,\n                         student_users=student_users)\n\n@app.route('/admin/create-exam', methods=['GET', 'POST'])\n@require_admin\ndef create_exam():\n    \"\"\"Create a new exam\"\"\"\n    if request.method == 'POST':\n        try:\n            # Get form data\n            title = request.form.get('title')\n            description = request.form.get('description')\n            subject_name = request.form.get('subject')\n            topic = request.form.get('topic')\n            difficulty = request.form.get('difficulty')\n            duration = int(request.form.get('duration', 60))\n            num_questions = int(request.form.get('num_questions', 10))\n            \n            # Create or get subject\n            subject = Subject.query.filter_by(name=subject_name).first()\n            if not subject:\n                subject = Subject()\n                subject.name = subject_name\n                db.session.add(subject)\n                db.session.commit()\n            \n            # Create exam\n            exam = Exam()\n            exam.title = title\n            exam.description = description\n            exam.subject_id = subject.id\n            exam.creator_id = current_user.id\n            exam.difficulty_level = difficulty\n            exam.duration_minutes = duration\n            exam.total_questions = num_questions\n            \n            db.session.add(exam)\n            db.session.commit()\n            \n            # Generate questions using AI\n            try:\n                ai_questions = generate_questions(\n                    subject=subject_name,\n                    topic=topic,\n                    difficulty=difficulty,\n                    num_questions=num_questions\n                )\n                \n                # Save questions to database\n                for i, q_data in enumerate(ai_questions):\n                    question = Question()\n                    question.exam_id = exam.id\n                    question.question_text = q_data['question_text']\n                    question.option_a = q_data['option_a']\n                    question.option_b = q_data['option_b']\n                    question.option_c = q_data['option_c']\n                    question.option_d = q_data['option_d']\n                    question.correct_answer = q_data['correct_answer']\n                    question.points = q_data.get('points', 1)\n                    question.order_index = i\n                    db.session.add(question)\n                \n                db.session.commit()\n                flash('Exam created successfully with AI-generated questions!', 'success')\n                return redirect(url_for('admin_dashboard'))\n                \n            except Exception as e:\n                logging.error(f\"Error generating questions: {str(e)}\")\n                flash(f'Exam created but failed to generate questions: {str(e)}', 'warning')\n                return redirect(url_for('admin_dashboard'))\n                \n        except Exception as e:\n            logging.error(f\"Error creating exam: {str(e)}\")\n            flash(f'Error creating exam: {str(e)}', 'error')\n    \n    subjects = Subject.query.all()\n    return render_template('admin/create_exam.html', subjects=subjects)\n\n@app.route('/admin/exam/<int:exam_id>/publish')\n@require_admin\ndef publish_exam(exam_id):\n    \"\"\"Publish an exam to make it available to students\"\"\"\n    exam = Exam.query.get_or_404(exam_id)\n    \n    if exam.creator_id != current_user.id:\n        flash('You can only publish your own exams.', 'error')\n        return redirect(url_for('admin_dashboard'))\n    \n    exam.is_published = True\n    db.session.commit()\n    \n    flash(f'Exam \"{exam.title}\" has been published and is now available to students.', 'success')\n    return redirect(url_for('admin_dashboard'))\n\n@app.route('/admin/exam/<int:exam_id>/unpublish')\n@require_admin\ndef unpublish_exam(exam_id):\n    \"\"\"Unpublish an exam\"\"\"\n    exam = Exam.query.get_or_404(exam_id)\n    \n    if exam.creator_id != current_user.id:\n        flash('You can only unpublish your own exams.', 'error')\n        return redirect(url_for('admin_dashboard'))\n    \n    exam.is_published = False\n    db.session.commit()\n    \n    flash(f'Exam \"{exam.title}\" has been unpublished.', 'success')\n    return redirect(url_for('admin_dashboard'))\n\n@app.route('/admin/exam/<int:exam_id>/results')\n@require_admin\ndef view_exam_results(exam_id):\n    \"\"\"View results for an exam\"\"\"\n    exam = Exam.query.get_or_404(exam_id)\n    \n    if exam.creator_id != current_user.id:\n        flash('You can only view results for your own exams.', 'error')\n        return redirect(url_for('admin_dashboard'))\n    \n    sessions = ExamSession.query.filter_by(\n        exam_id=exam_id,\n        is_submitted=True\n    ).order_by(ExamSession.score.desc()).all()\n    \n    stats = get_exam_statistics(exam_id)\n    \n    return render_template('admin/view_results.html', exam=exam, sessions=sessions, stats=stats)\n\n# Student Routes\n@app.route('/student')\n@require_login\ndef student_dashboard():\n    \"\"\"Student dashboard with available exams\"\"\"\n    # Get published exams\n    available_exams = Exam.query.filter_by(is_published=True, is_active=True).all()\n    \n    # Get student's exam history\n    exam_history = get_student_exam_history(current_user.id)\n    \n    # Get active exam sessions\n    active_sessions = ExamSession.query.filter_by(\n        student_id=current_user.id,\n        is_submitted=False\n    ).all()\n    \n    return render_template('student/dashboard.html', \n                         available_exams=available_exams, \n                         exam_history=exam_history,\n                         active_sessions=active_sessions)\n\n@app.route('/student/exam/<int:exam_id>/start')\n@require_login\ndef start_exam(exam_id):\n    \"\"\"Start an exam\"\"\"\n    exam = Exam.query.get_or_404(exam_id)\n    \n    if not exam.is_published or not exam.is_active:\n        flash('This exam is not available.', 'error')\n        return redirect(url_for('student_dashboard'))\n    \n    # Check if student already has a submitted session for this exam\n    existing_session = ExamSession.query.filter_by(\n        exam_id=exam_id,\n        student_id=current_user.id,\n        is_submitted=True\n    ).first()\n    \n    if existing_session:\n        flash('You have already completed this exam.', 'warning')\n        return redirect(url_for('student_dashboard'))\n    \n    # Create or get active session\n    exam_session = create_exam_session(exam_id, current_user.id)\n    \n    return redirect(url_for('take_exam', session_id=exam_session.id))\n\n@app.route('/student/exam/session/<int:session_id>')\n@require_login\ndef take_exam(session_id):\n    \"\"\"Take an exam\"\"\"\n    exam_session = ExamSession.query.get_or_404(session_id)\n    \n    if exam_session.student_id != current_user.id:\n        flash('You can only access your own exam sessions.', 'error')\n        return redirect(url_for('student_dashboard'))\n    \n    if exam_session.is_submitted:\n        flash('This exam has already been submitted.', 'info')\n        return redirect(url_for('view_results', session_id=session_id))\n    \n    # Check if time is up\n    time_remaining = get_exam_time_remaining(exam_session)\n    if time_remaining <= 0:\n        flash('Time is up! Your exam has been automatically submitted.', 'warning')\n        return redirect(url_for('view_results', session_id=session_id))\n    \n    # Get randomized questions for this student\n    questions = get_randomized_questions(exam_session.exam_id, current_user.id)\n    \n    # Get existing answers\n    existing_answers = {}\n    answers = Answer.query.filter_by(exam_session_id=session_id).all()\n    for answer in answers:\n        existing_answers[answer.question_id] = answer.student_answer\n    \n    return render_template('student/exam.html', \n                         exam_session=exam_session,\n                         questions=questions,\n                         existing_answers=existing_answers,\n                         time_remaining=time_remaining)\n\n@app.route('/student/exam/session/<int:session_id>/submit-answer', methods=['POST'])\n@require_login\ndef submit_exam_answer(session_id):\n    \"\"\"Submit an answer for a question\"\"\"\n    exam_session = ExamSession.query.get_or_404(session_id)\n    \n    if exam_session.student_id != current_user.id:\n        return jsonify({'error': 'Unauthorized'}), 403\n    \n    if exam_session.is_submitted:\n        return jsonify({'error': 'Exam already submitted'}), 400\n    \n    if not request.json:\n        return jsonify({'error': 'Invalid request format'}), 400\n    \n    question_id = request.json.get('question_id')\n    student_answer = request.json.get('answer')\n    \n    try:\n        submit_answer(session_id, question_id, student_answer)\n        return jsonify({'success': True})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/student/exam/session/<int:session_id>/submit', methods=['POST'])\n@require_login\ndef submit_exam(session_id):\n    \"\"\"Submit the entire exam\"\"\"\n    exam_session = ExamSession.query.get_or_404(session_id)\n    \n    if exam_session.student_id != current_user.id:\n        flash('You can only submit your own exam sessions.', 'error')\n        return redirect(url_for('student_dashboard'))\n    \n    if exam_session.is_submitted:\n        flash('This exam has already been submitted.', 'info')\n        return redirect(url_for('view_results', session_id=session_id))\n    \n    # Submit any pending answers from the form\n    for key, value in request.form.items():\n        if key.startswith('question_'):\n            question_id = int(key.replace('question_', ''))\n            if value:\n                submit_answer(session_id, question_id, value)\n    \n    # Finish the exam session\n    finish_exam_session(session_id)\n    \n    flash('Exam submitted successfully!', 'success')\n    return redirect(url_for('view_results', session_id=session_id))\n\n@app.route('/student/exam/session/<int:session_id>/results')\n@require_login\ndef view_results(session_id):\n    \"\"\"View exam results\"\"\"\n    exam_session = ExamSession.query.get_or_404(session_id)\n    \n    if exam_session.student_id != current_user.id:\n        flash('You can only view your own exam results.', 'error')\n        return redirect(url_for('student_dashboard'))\n    \n    if not exam_session.is_submitted:\n        flash('This exam has not been submitted yet.', 'warning')\n        return redirect(url_for('take_exam', session_id=session_id))\n    \n    # Get questions and answers\n    questions = Question.query.filter_by(exam_id=exam_session.exam_id).all()\n    answers = Answer.query.filter_by(exam_session_id=session_id).all()\n    \n    # Create answer lookup\n    answer_lookup = {answer.question_id: answer for answer in answers}\n    \n    return render_template('student/results.html', \n                         exam_session=exam_session,\n                         questions=questions,\n                         answer_lookup=answer_lookup)\n\n@app.route('/admin/make-admin/<user_id>')\n@require_admin\ndef make_admin(user_id):\n    \"\"\"Make a user an admin - for development purposes\"\"\"\n    user = User.query.get_or_404(user_id)\n    user.role = 'admin'\n    db.session.commit()\n    flash(f'User {user.email} is now an admin.', 'success')\n    return redirect(url_for('admin_dashboard'))\n\n# API Routes for AJAX calls\n@app.route('/api/exam/session/<int:session_id>/time-remaining')\n@require_login\ndef get_time_remaining(session_id):\n    \"\"\"Get remaining time for an exam session\"\"\"\n    exam_session = ExamSession.query.get_or_404(session_id)\n    \n    if exam_session.student_id != current_user.id:\n        return jsonify({'error': 'Unauthorized'}), 403\n    \n    time_remaining = get_exam_time_remaining(exam_session)\n    \n    return jsonify({\n        'time_remaining': time_remaining,\n        'is_submitted': exam_session.is_submitted\n    })\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found(error):\n    return render_template('404.html'), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    return render_template('500.html'), 500\n","size_bytes":15360},"static/css/custom.css":{"content":"/* Custom styles for AI Exam System */\n\n/* Exam Interface Styles */\n.exam-container {\n    min-height: 100vh;\n    background-color: var(--bs-dark);\n}\n\n.exam-header {\n    z-index: 1030;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}\n\n.exam-content {\n    margin-top: 100px;\n    padding-bottom: 2rem;\n}\n\n.timer-display {\n    font-family: 'Courier New', monospace;\n    font-size: 1.5rem;\n    font-weight: bold;\n    color: var(--bs-light);\n}\n\n.timer-progress {\n    width: 100px;\n    margin-top: 0.5rem;\n}\n\n.timer-warning {\n    color: var(--bs-warning) !important;\n}\n\n.timer-danger {\n    color: var(--bs-danger) !important;\n    animation: pulse 1s infinite;\n}\n\n@keyframes pulse {\n    0% { opacity: 1; }\n    50% { opacity: 0.5; }\n    100% { opacity: 1; }\n}\n\n/* Question Cards */\n.question-card {\n    border: 1px solid var(--bs-border-color);\n    transition: all 0.3s ease;\n}\n\n.question-card:hover {\n    box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n}\n\n.question-text {\n    font-size: 1.1rem;\n    line-height: 1.6;\n    font-weight: 500;\n}\n\n.option-label {\n    font-size: 1rem;\n    line-height: 1.5;\n    cursor: pointer;\n    padding: 0.75rem;\n    border-radius: 0.375rem;\n    transition: background-color 0.2s ease;\n    display: block;\n    margin-bottom: 0;\n}\n\n.option-label:hover {\n    background-color: var(--bs-secondary-bg);\n}\n\n.form-check-input:checked + .option-label {\n    background-color: var(--bs-primary-bg);\n    border-color: var(--bs-primary);\n}\n\n/* Navigation Panel */\n.navigation-panel {\n    position: relative;\n}\n\n.question-grid {\n    display: grid;\n    grid-template-columns: repeat(5, 1fr);\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.question-nav-btn {\n    aspect-ratio: 1;\n    border-radius: 50%;\n    font-weight: bold;\n    transition: all 0.2s ease;\n}\n\n.question-nav-btn.answered {\n    background-color: var(--bs-success);\n    border-color: var(--bs-success);\n    color: white;\n}\n\n.question-nav-btn.current {\n    background-color: var(--bs-primary);\n    border-color: var(--bs-primary);\n    color: white;\n}\n\n.question-nav-btn:hover {\n    transform: scale(1.1);\n}\n\n.legend-color {\n    width: 12px;\n    height: 12px;\n    border-radius: 2px;\n}\n\n/* Progress Indicators */\n.progress-info {\n    font-size: 0.9rem;\n}\n\n#progress-text {\n    font-weight: bold;\n}\n\n/* Results Page Styles */\n.score-circle {\n    width: 120px;\n    height: 120px;\n    border: 4px solid currentColor;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 2rem;\n    font-weight: bold;\n    margin: 0 auto;\n}\n\n.result-stat {\n    text-align: center;\n    padding: 1rem 0;\n}\n\n.result-stat i {\n    color: var(--bs-secondary);\n}\n\n.result-stat h6 {\n    margin: 0.5rem 0 0.25rem 0;\n    font-size: 1.25rem;\n}\n\n.question-review {\n    background-color: var(--bs-body-bg);\n}\n\n.option-item {\n    transition: all 0.2s ease;\n}\n\n.option-circle {\n    width: 20px;\n    height: 20px;\n    border: 2px solid var(--bs-border-color);\n    border-radius: 50%;\n}\n\n.option-indicator {\n    width: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Anti-cheat Warning Styles */\n.tab-switch-warning {\n    position: fixed;\n    top: 100px;\n    left: 50%;\n    transform: translateX(-50%);\n    z-index: 1040;\n    max-width: 500px;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .exam-content {\n        margin-top: 120px;\n    }\n    \n    .timer-display {\n        font-size: 1.2rem;\n    }\n    \n    .question-grid {\n        grid-template-columns: repeat(4, 1fr);\n    }\n    \n    .score-circle {\n        width: 100px;\n        height: 100px;\n        font-size: 1.5rem;\n    }\n    \n    .navigation-panel {\n        margin-top: 2rem;\n    }\n    \n    .navigation-panel .card {\n        position: relative !important;\n        top: auto !important;\n    }\n}\n\n@media (max-width: 576px) {\n    .question-grid {\n        grid-template-columns: repeat(3, 1fr);\n    }\n    \n    .option-label {\n        font-size: 0.9rem;\n        padding: 0.5rem;\n    }\n    \n    .result-stat h6 {\n        font-size: 1rem;\n    }\n}\n\n/* Print Styles */\n@media print {\n    .navbar,\n    .exam-header,\n    .navigation-panel,\n    .btn,\n    .modal,\n    footer {\n        display: none !important;\n    }\n    \n    .exam-content {\n        margin-top: 0;\n    }\n    \n    .question-card {\n        break-inside: avoid;\n        margin-bottom: 1rem;\n    }\n    \n    .container,\n    .container-fluid {\n        max-width: none;\n        width: 100%;\n        padding: 0;\n    }\n    \n    body.print-mode {\n        background: white !important;\n        color: black !important;\n    }\n    \n    .print-mode .card {\n        border: 1px solid #ddd !important;\n        background: white !important;\n    }\n    \n    .print-mode .bg-success {\n        background-color: #d4edda !important;\n    }\n    \n    .print-mode .bg-danger {\n        background-color: #f8d7da !important;\n    }\n    \n    .print-mode .text-success {\n        color: #155724 !important;\n    }\n    \n    .print-mode .text-danger {\n        color: #721c24 !important;\n    }\n}\n\n/* Focus and Accessibility */\n.form-check-input:focus {\n    box-shadow: 0 0 0 0.25rem rgba(var(--bs-primary-rgb), 0.25);\n}\n\n.question-nav-btn:focus {\n    box-shadow: 0 0 0 0.25rem rgba(var(--bs-primary-rgb), 0.25);\n}\n\n/* Loading States */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n.spinner-border-sm {\n    width: 1rem;\n    height: 1rem;\n}\n\n/* Custom Alert Styles */\n.alert-exam-warning {\n    background-color: var(--bs-warning-bg-subtle);\n    border-color: var(--bs-warning-border-subtle);\n    color: var(--bs-warning-text);\n}\n\n/* Exam Statistics Cards */\n.stat-card {\n    transition: transform 0.2s ease;\n}\n\n.stat-card:hover {\n    transform: translateY(-2px);\n}\n\n/* Smooth Scrolling */\nhtml {\n    scroll-behavior: smooth;\n}\n\n/* Custom Scrollbar */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bs-secondary-bg);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--bs-secondary);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--bs-secondary-color);\n}\n\n/* Animation Classes */\n.fade-in {\n    animation: fadeIn 0.5s ease-in;\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n.slide-in {\n    animation: slideIn 0.3s ease-out;\n}\n\n@keyframes slideIn {\n    from { transform: translateX(-100%); }\n    to { transform: translateX(0); }\n}\n\n/* High Contrast Mode Support */\n@media (prefers-contrast: high) {\n    .question-card {\n        border-width: 2px;\n    }\n    \n    .option-label {\n        border: 1px solid var(--bs-border-color);\n    }\n    \n    .form-check-input:checked + .option-label {\n        border-width: 2px;\n    }\n}\n\n/* Reduced Motion Support */\n@media (prefers-reduced-motion: reduce) {\n    *,\n    *::before,\n    *::after {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n    }\n}\n","size_bytes":6959},"static/js/exam.js":{"content":"/**\n * Exam Interface JavaScript\n * Handles exam functionality, navigation, answer submission, and anti-cheat measures\n */\n\nclass ExamManager {\n    constructor() {\n        this.sessionId = document.querySelector('meta[name=\"exam-session-id\"]').content;\n        this.totalQuestions = document.querySelectorAll('.question-card').length;\n        this.answeredQuestions = new Set();\n        this.currentQuestion = 1;\n        this.tabSwitchCount = 0;\n        this.examSubmitted = false;\n        this.autoSaveInterval = null;\n        \n        this.init();\n    }\n    \n    init() {\n        this.setupEventListeners();\n        this.updateNavigationButtons();\n        this.updateProgress();\n        this.startAutoSave();\n        this.setupAntiCheat();\n        this.scrollToFirstQuestion();\n        \n        console.log('Exam Manager initialized');\n    }\n    \n    setupEventListeners() {\n        // Question input change handlers\n        document.querySelectorAll('.question-input').forEach(input => {\n            input.addEventListener('change', (e) => {\n                this.handleAnswerChange(e);\n            });\n            \n            // For text areas, also listen to input events for real-time saving\n            if (input.tagName === 'TEXTAREA') {\n                input.addEventListener('input', (e) => {\n                    this.handleAnswerChange(e);\n                });\n            }\n        });\n        \n        // Navigation button handlers\n        document.querySelectorAll('.question-nav-btn').forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                this.navigateToQuestion(parseInt(e.target.dataset.questionNumber));\n            });\n        });\n        \n        // Submit button handler\n        document.getElementById('submit-btn').addEventListener('click', (e) => {\n            e.preventDefault();\n            this.showSubmitConfirmation();\n        });\n        \n        // Review button handler\n        document.getElementById('review-btn').addEventListener('click', (e) => {\n            this.showReviewMode();\n        });\n        \n        // Modal confirmation handler\n        document.getElementById('confirm-submit').addEventListener('click', (e) => {\n            this.submitExam();\n        });\n        \n        // Form submit handler\n        document.getElementById('exam-form').addEventListener('submit', (e) => {\n            if (!this.examSubmitted) {\n                e.preventDefault();\n                this.showSubmitConfirmation();\n            }\n        });\n        \n        // Keyboard navigation\n        document.addEventListener('keydown', (e) => {\n            this.handleKeyNavigation(e);\n        });\n    }\n    \n    handleAnswerChange(event) {\n        const input = event.target;\n        const questionId = input.dataset.questionId;\n        const answer = input.value;\n        \n        // Mark question as answered\n        if (answer && answer.trim() !== '') {\n            this.answeredQuestions.add(questionId);\n        } else {\n            this.answeredQuestions.delete(questionId);\n        }\n        \n        // Update UI\n        this.updateNavigationButtons();\n        this.updateProgress();\n        this.updateSubmitButton();\n        \n        // Auto-save answer\n        this.saveAnswer(questionId, answer);\n        \n        console.log(`Answer changed for question ${questionId}:`, answer);\n    }\n    \n    async saveAnswer(questionId, answer) {\n        try {\n            const response = await fetch(`/student/exam/session/${this.sessionId}/submit-answer`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    question_id: questionId,\n                    answer: answer\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error('Failed to save answer');\n            }\n            \n            console.log(`Answer saved for question ${questionId}`);\n        } catch (error) {\n            console.error('Error saving answer:', error);\n            // Show temporary error message\n            this.showTempMessage('Failed to save answer. Please try again.', 'warning');\n        }\n    }\n    \n    navigateToQuestion(questionNumber) {\n        const questionCard = document.getElementById(`question-${questionNumber}`);\n        if (questionCard) {\n            questionCard.scrollIntoView({ \n                behavior: 'smooth', \n                block: 'start',\n                inline: 'nearest'\n            });\n            \n            this.currentQuestion = questionNumber;\n            this.updateNavigationButtons();\n        }\n    }\n    \n    updateNavigationButtons() {\n        document.querySelectorAll('.question-nav-btn').forEach(btn => {\n            const questionNumber = parseInt(btn.dataset.questionNumber);\n            const questionId = btn.dataset.questionId || this.getQuestionIdByNumber(questionNumber);\n            \n            // Remove existing classes\n            btn.classList.remove('answered', 'current');\n            \n            // Add appropriate classes\n            if (this.answeredQuestions.has(questionId)) {\n                btn.classList.add('answered');\n            }\n            \n            if (questionNumber === this.currentQuestion) {\n                btn.classList.add('current');\n            }\n        });\n    }\n    \n    updateProgress() {\n        const answeredCount = this.answeredQuestions.size;\n        const progressPercentage = (answeredCount / this.totalQuestions) * 100;\n        \n        document.getElementById('progress-text').textContent = `${answeredCount} / ${this.totalQuestions}`;\n        document.getElementById('progress-bar').style.width = `${progressPercentage}%`;\n    }\n    \n    updateSubmitButton() {\n        const submitBtn = document.getElementById('submit-btn');\n        const reviewBtn = document.getElementById('review-btn');\n        \n        if (this.answeredQuestions.size > 0) {\n            submitBtn.disabled = false;\n            reviewBtn.disabled = false;\n        } else {\n            submitBtn.disabled = true;\n            reviewBtn.disabled = true;\n        }\n    }\n    \n    showSubmitConfirmation() {\n        const answeredCount = this.answeredQuestions.size;\n        const unansweredCount = this.totalQuestions - answeredCount;\n        \n        document.getElementById('answered-count').textContent = answeredCount;\n        \n        // Update time remaining text\n        const timeRemainingElement = document.getElementById('time-remaining-text');\n        if (window.examTimer) {\n            const timeLeft = window.examTimer.getTimeRemaining();\n            const minutes = Math.floor(timeLeft / 60);\n            const seconds = timeLeft % 60;\n            timeRemainingElement.textContent = `Time remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;\n        }\n        \n        // Show warning for unanswered questions\n        if (unansweredCount > 0) {\n            const warningDiv = document.createElement('div');\n            warningDiv.className = 'alert alert-warning mt-2';\n            warningDiv.innerHTML = `<strong>Warning:</strong> You have ${unansweredCount} unanswered question${unansweredCount > 1 ? 's' : ''}. These will be marked as incorrect.`;\n            \n            const existingWarning = document.querySelector('#submitModal .alert-warning');\n            if (existingWarning) {\n                existingWarning.remove();\n            }\n            \n            document.querySelector('#submitModal .modal-body').appendChild(warningDiv);\n        }\n        \n        const modal = new bootstrap.Modal(document.getElementById('submitModal'));\n        modal.show();\n    }\n    \n    showReviewMode() {\n        // Scroll to top and highlight unanswered questions\n        window.scrollTo({ top: 0, behavior: 'smooth' });\n        \n        // Highlight unanswered questions\n        document.querySelectorAll('.question-card').forEach((card, index) => {\n            const questionNumber = index + 1;\n            const questionId = this.getQuestionIdByNumber(questionNumber);\n            \n            if (!this.answeredQuestions.has(questionId)) {\n                card.classList.add('border-warning');\n                setTimeout(() => {\n                    card.classList.remove('border-warning');\n                }, 3000);\n            }\n        });\n        \n        this.showTempMessage('Unanswered questions are highlighted in yellow.', 'info');\n    }\n    \n    submitExam() {\n        this.examSubmitted = true;\n        \n        // Stop auto-save\n        if (this.autoSaveInterval) {\n            clearInterval(this.autoSaveInterval);\n        }\n        \n        // Stop timer\n        if (window.examTimer) {\n            window.examTimer.stop();\n        }\n        \n        // Disable all inputs\n        document.querySelectorAll('.question-input').forEach(input => {\n            input.disabled = true;\n        });\n        \n        // Show loading state\n        const submitBtn = document.getElementById('confirm-submit');\n        submitBtn.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Submitting...';\n        submitBtn.disabled = true;\n        \n        // Submit the form\n        document.getElementById('exam-form').submit();\n    }\n    \n    startAutoSave() {\n        this.autoSaveInterval = setInterval(() => {\n            // Auto-save is handled by individual answer changes\n            console.log('Auto-save interval tick');\n        }, 30000); // 30 seconds\n    }\n    \n    setupAntiCheat() {\n        let isVisible = true;\n        \n        // Tab/window visibility change detection\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden && isVisible) {\n                this.tabSwitchCount++;\n                this.logTabSwitch();\n                this.showTabSwitchWarning();\n                isVisible = false;\n            } else if (!document.hidden) {\n                isVisible = true;\n            }\n        });\n        \n        // Window focus/blur events\n        window.addEventListener('blur', () => {\n            if (isVisible) {\n                this.tabSwitchCount++;\n                this.logTabSwitch();\n            }\n        });\n        \n        // Prevent right-click context menu\n        document.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        });\n        \n        // Prevent common keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            // Prevent F12, Ctrl+Shift+I, Ctrl+U, etc.\n            if (\n                e.key === 'F12' ||\n                (e.ctrlKey && e.shiftKey && e.key === 'I') ||\n                (e.ctrlKey && e.shiftKey && e.key === 'C') ||\n                (e.ctrlKey && e.key === 'u')\n            ) {\n                e.preventDefault();\n                this.showTempMessage('This action is not allowed during the exam.', 'warning');\n            }\n        });\n        \n        console.log('Anti-cheat measures activated');\n    }\n    \n    logTabSwitch() {\n        console.log(`Tab switch detected. Count: ${this.tabSwitchCount}`);\n        \n        // Log to server (you could implement this)\n        // this.sendTabSwitchLog();\n    }\n    \n    showTabSwitchWarning() {\n        if (this.tabSwitchCount <= 3) { // Only show for first few violations\n            const modal = new bootstrap.Modal(document.getElementById('tabSwitchModal'));\n            modal.show();\n        }\n    }\n    \n    handleKeyNavigation(event) {\n        if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT') {\n            return; // Don't interfere with text input\n        }\n        \n        switch(event.key) {\n            case 'ArrowUp':\n                event.preventDefault();\n                this.navigateToQuestion(Math.max(1, this.currentQuestion - 1));\n                break;\n            case 'ArrowDown':\n                event.preventDefault();\n                this.navigateToQuestion(Math.min(this.totalQuestions, this.currentQuestion + 1));\n                break;\n            case 'Enter':\n                if (event.ctrlKey) {\n                    event.preventDefault();\n                    this.showSubmitConfirmation();\n                }\n                break;\n        }\n    }\n    \n    getQuestionIdByNumber(questionNumber) {\n        const questionCard = document.querySelector(`.question-card:nth-child(${questionNumber})`);\n        return questionCard ? questionCard.id.replace('question-', '') : null;\n    }\n    \n    showTempMessage(message, type = 'info') {\n        const alertDiv = document.createElement('div');\n        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;\n        alertDiv.style.cssText = 'top: 120px; right: 20px; z-index: 1050; max-width: 400px;';\n        alertDiv.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        document.body.appendChild(alertDiv);\n        \n        // Auto-remove after 5 seconds\n        setTimeout(() => {\n            if (alertDiv.parentNode) {\n                alertDiv.remove();\n            }\n        }, 5000);\n    }\n    \n    scrollToFirstQuestion() {\n        const firstQuestion = document.querySelector('.question-card');\n        if (firstQuestion) {\n            firstQuestion.scrollIntoView({ behavior: 'smooth' });\n        }\n    }\n    \n    // Public methods for external access\n    getAnsweredCount() {\n        return this.answeredQuestions.size;\n    }\n    \n    getTotalQuestions() {\n        return this.totalQuestions;\n    }\n    \n    getTabSwitchCount() {\n        return this.tabSwitchCount;\n    }\n}\n\n// Initialize exam manager when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function() {\n    window.examManager = new ExamManager();\n    \n    // Initialize feather icons\n    feather.replace();\n    \n    console.log('Exam interface loaded successfully');\n});\n\n// Prevent page refresh/navigation without confirmation\nwindow.addEventListener('beforeunload', function(e) {\n    if (!window.examManager || !window.examManager.examSubmitted) {\n        e.preventDefault();\n        e.returnValue = 'Are you sure you want to leave? Your exam progress may be lost.';\n        return e.returnValue;\n    }\n});\n","size_bytes":14288},"static/js/timer.js":{"content":"/**\n * Exam Timer JavaScript\n * Handles countdown timer, progress bar, and automatic submission\n */\n\nclass ExamTimer {\n    constructor() {\n        this.duration = parseInt(document.querySelector('meta[name=\"exam-duration\"]').content) * 60; // Convert to seconds\n        this.timeRemaining = parseInt(document.querySelector('meta[name=\"time-remaining\"]').content);\n        this.sessionId = document.querySelector('meta[name=\"exam-session-id\"]').content;\n        this.timerInterval = null;\n        this.warningThresholds = [300, 120, 60, 30]; // Warning at 5min, 2min, 1min, 30sec\n        this.warningsShown = new Set();\n        this.isRunning = false;\n        \n        this.init();\n    }\n    \n    init() {\n        this.updateDisplay();\n        this.updateProgressBar();\n        this.start();\n        \n        console.log(`Timer initialized: ${this.timeRemaining} seconds remaining`);\n    }\n    \n    start() {\n        if (this.isRunning) return;\n        \n        this.isRunning = true;\n        this.timerInterval = setInterval(() => {\n            this.tick();\n        }, 1000);\n        \n        console.log('Timer started');\n    }\n    \n    stop() {\n        if (this.timerInterval) {\n            clearInterval(this.timerInterval);\n            this.timerInterval = null;\n            this.isRunning = false;\n            console.log('Timer stopped');\n        }\n    }\n    \n    tick() {\n        this.timeRemaining--;\n        \n        this.updateDisplay();\n        this.updateProgressBar();\n        this.checkWarnings();\n        \n        // Auto-submit when time is up\n        if (this.timeRemaining <= 0) {\n            this.timeUp();\n        }\n        \n        // Sync with server every 30 seconds\n        if (this.timeRemaining % 30 === 0) {\n            this.syncWithServer();\n        }\n    }\n    \n    updateDisplay() {\n        const minutes = Math.floor(Math.abs(this.timeRemaining) / 60);\n        const seconds = Math.abs(this.timeRemaining) % 60;\n        \n        const minutesElement = document.getElementById('timer-minutes');\n        const secondsElement = document.getElementById('timer-seconds');\n        const timerDisplay = document.getElementById('timer-display');\n        \n        if (minutesElement && secondsElement) {\n            minutesElement.textContent = minutes.toString().padStart(2, '0');\n            secondsElement.textContent = seconds.toString().padStart(2, '0');\n            \n            // Add visual warnings\n            if (this.timeRemaining <= 0) {\n                timerDisplay.className = 'timer-display timer-danger';\n                minutesElement.textContent = '00';\n                secondsElement.textContent = '00';\n            } else if (this.timeRemaining <= 300) { // 5 minutes\n                timerDisplay.className = 'timer-display timer-danger';\n            } else if (this.timeRemaining <= 600) { // 10 minutes\n                timerDisplay.className = 'timer-display timer-warning';\n            } else {\n                timerDisplay.className = 'timer-display';\n            }\n        }\n    }\n    \n    updateProgressBar() {\n        const progressBar = document.getElementById('timer-progress-bar');\n        if (progressBar && this.duration > 0) {\n            const percentage = Math.max(0, (this.timeRemaining / this.duration) * 100);\n            progressBar.style.width = `${percentage}%`;\n            \n            // Change color based on time remaining\n            if (percentage <= 8.33) { // 5 minutes for 60-minute exam\n                progressBar.className = 'progress-bar bg-danger';\n            } else if (percentage <= 16.67) { // 10 minutes for 60-minute exam\n                progressBar.className = 'progress-bar bg-warning';\n            } else {\n                progressBar.className = 'progress-bar bg-primary';\n            }\n        }\n    }\n    \n    checkWarnings() {\n        this.warningThresholds.forEach(threshold => {\n            if (this.timeRemaining <= threshold && !this.warningsShown.has(threshold)) {\n                this.showTimeWarning(threshold);\n                this.warningsShown.add(threshold);\n            }\n        });\n    }\n    \n    showTimeWarning(seconds) {\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        \n        let message;\n        if (minutes > 0) {\n            message = `${minutes} minute${minutes > 1 ? 's' : ''} remaining!`;\n        } else {\n            message = `${remainingSeconds} second${remainingSeconds > 1 ? 's' : ''} remaining!`;\n        }\n        \n        this.showTimerAlert(message, 'warning');\n        \n        // Play warning sound (if allowed by browser)\n        this.playWarningSound();\n        \n        console.log(`Time warning: ${message}`);\n    }\n    \n    showTimerAlert(message, type = 'info') {\n        const alertDiv = document.createElement('div');\n        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;\n        alertDiv.style.cssText = 'top: 120px; left: 50%; transform: translateX(-50%); z-index: 1050; max-width: 400px;';\n        alertDiv.innerHTML = `\n            <div class=\"d-flex align-items-center\">\n                <i data-feather=\"clock\" class=\"me-2\"></i>\n                <strong>${message}</strong>\n            </div>\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        document.body.appendChild(alertDiv);\n        feather.replace();\n        \n        // Auto-remove after 5 seconds\n        setTimeout(() => {\n            if (alertDiv.parentNode) {\n                alertDiv.remove();\n            }\n        }, 5000);\n    }\n    \n    playWarningSound() {\n        try {\n            // Create a simple beep sound using Web Audio API\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = 800; // 800 Hz\n            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.5);\n        } catch (error) {\n            console.log('Could not play warning sound:', error);\n        }\n    }\n    \n    timeUp() {\n        this.stop();\n        \n        this.showTimerAlert('Time is up! Your exam is being submitted automatically.', 'danger');\n        \n        // Automatically submit the exam\n        setTimeout(() => {\n            if (window.examManager && !window.examManager.examSubmitted) {\n                window.examManager.submitExam();\n            } else {\n                // Fallback: submit form directly\n                document.getElementById('exam-form').submit();\n            }\n        }, 2000);\n        \n        console.log('Time up - auto-submitting exam');\n    }\n    \n    async syncWithServer() {\n        try {\n            const response = await fetch(`/api/exam/session/${this.sessionId}/time-remaining`);\n            if (response.ok) {\n                const data = await response.json();\n                \n                // Check if exam was submitted from another tab/device\n                if (data.is_submitted) {\n                    this.stop();\n                    window.location.reload();\n                    return;\n                }\n                \n                // Sync time with server (in case of clock drift)\n                const serverTime = data.time_remaining;\n                const timeDiff = Math.abs(this.timeRemaining - serverTime);\n                \n                if (timeDiff > 5) { // Sync if difference is more than 5 seconds\n                    console.log(`Time sync: Local ${this.timeRemaining}s, Server ${serverTime}s`);\n                    this.timeRemaining = serverTime;\n                    this.updateDisplay();\n                    this.updateProgressBar();\n                }\n            }\n        } catch (error) {\n            console.error('Failed to sync with server:', error);\n        }\n    }\n    \n    // Public methods\n    getTimeRemaining() {\n        return this.timeRemaining;\n    }\n    \n    getFormattedTime() {\n        const minutes = Math.floor(Math.abs(this.timeRemaining) / 60);\n        const seconds = Math.abs(this.timeRemaining) % 60;\n        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    \n    addTime(seconds) {\n        this.timeRemaining += seconds;\n        this.updateDisplay();\n        this.updateProgressBar();\n        console.log(`Added ${seconds} seconds to timer`);\n    }\n    \n    pause() {\n        if (this.isRunning) {\n            this.stop();\n            console.log('Timer paused');\n        }\n    }\n    \n    resume() {\n        if (!this.isRunning && this.timeRemaining > 0) {\n            this.start();\n            console.log('Timer resumed');\n        }\n    }\n}\n\n// Initialize timer when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Only initialize timer on exam pages\n    if (document.querySelector('meta[name=\"exam-session-id\"]')) {\n        window.examTimer = new ExamTimer();\n        console.log('Exam timer loaded successfully');\n    }\n});\n\n// Handle page visibility for timer accuracy\ndocument.addEventListener('visibilitychange', function() {\n    if (window.examTimer) {\n        if (document.hidden) {\n            // Page is hidden - could pause timer or continue running\n            console.log('Page hidden - timer continues running');\n        } else {\n            // Page is visible - sync with server\n            console.log('Page visible - syncing timer');\n            window.examTimer.syncWithServer();\n        }\n    }\n});\n\n// Expose timer functions globally for debugging\nwindow.timerDebug = {\n    getTime: () => window.examTimer ? window.examTimer.getFormattedTime() : 'No timer',\n    addTime: (seconds) => window.examTimer ? window.examTimer.addTime(seconds) : 'No timer',\n    pause: () => window.examTimer ? window.examTimer.pause() : 'No timer',\n    resume: () => window.examTimer ? window.examTimer.resume() : 'No timer'\n};\n","size_bytes":10290}}}